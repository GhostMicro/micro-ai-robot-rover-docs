# ü¶æ Module: Body (‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏±‡∏ö‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏ã‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß)

‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô "‡∏Å‡∏•‡πâ‡∏≤‡∏°‡πÄ‡∏ô‡∏∑‡πâ‡∏≠" ‡πÅ‡∏•‡∏∞ "‡∏™‡∏±‡∏ç‡∏ä‡∏≤‡∏ï‡∏ç‡∏≤‡∏ì" ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πà‡∏ô‡∏¢‡∏ô‡∏ï‡πå

- **Movement & Power:** ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå (Movement) ‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏π‡∏á (High-Intensity LED / Searchlight)
- **SOS Actuator:** ‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏â‡∏∏‡∏Å‡πÄ‡∏â‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á (Buzzer) ‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏Å‡∏∞‡∏û‡∏£‡∏¥‡∏ö (Strobe Light) ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏£‡∏≠‡∏î‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï
- **Boundary & Patrol:** ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î "Area Patrol" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏≤‡∏î‡∏ï‡∏£‡∏∞‡πÄ‡∏ß‡∏ô‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ ‡πÅ‡∏•‡∏∞ "Auto RTH" ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏∏‡∏î‡πÄ‡∏Ç‡∏ï
- **Local Initiative (Emergency):** ‡∏´‡∏≤‡∏Å‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Header ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏ä‡∏¥‡∏î‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏∑‡∏î Nano ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (Local Override)
- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Standalone (Bluetooth) ‡πÅ‡∏•‡∏∞ System (Header)

## üõ†Ô∏è Hardware Requirements
- **MCU:** Arduino Nano (V3)
- **Drivers:** L298N ‡∏´‡∏£‡∏∑‡∏≠ MOSFET Modules
- **Sensors:** 4-6x Ultrasonic (HC-SR04), Bluetooth HC-05 (Optional)

## ‚öôÔ∏è Control Priority Logic
1. **Standalone Mode:** ‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å Bluetooth (HC-05) ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Header
2. **Override Mode:** ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏à‡∏≤‡∏Å **Signal Check Pin** (Header ‡πÄ‡∏™‡∏µ‡∏¢‡∏ö‡∏≠‡∏¢‡∏π‡πà) ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô Bluetooth ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å UART (Header) ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô

## üìç Reserved Pins (Arduino Nano)
| Function           | Nano Pin         | Note                            |
| :----------------- | :--------------- | :------------------------------ |
| **Motor L PWM**    | D5, D6           | ‡∏Ñ‡∏∏‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß/‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á                 |
| **Motor R PWM**    | D9, D10          | ‡∏Ñ‡∏∏‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß/‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á                 |
| **UART (Header)**  | D0 (RX), D1 (TX) | ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å STM32                  |
| **Header Check**   | D2               | High = Header Attached          |
| **Lipo Monitor**   | A0               | ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏î‡πÑ‡∏ü‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà (Propulsion)    |
| **Searchlight**    | D3               | **Illumination:** ‡∏ï‡πà‡∏≠‡∏ú‡πà‡∏≤‡∏ô MOSFET  |
| **Buzzer**         | D4               | **SOS Audio:** ‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡∏π‡πâ‡∏†‡∏±‡∏¢   |
| **Digital Strobe** | D7               | **SOS Visual:** ‡πÑ‡∏ü‡∏Å‡∏∞‡∏û‡∏£‡∏¥‡∏ö‡πÅ‡∏à‡πâ‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á |
| **Light FX**       | D11              | ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ü‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì/‡πÑ‡∏ü‡πÄ‡∏ó‡πà                |

---

## üíª Latest Firmware: Arduino Nano Actuator

‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Arduino Nano (Body) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏Ç‡∏±‡∏ö‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÑ‡∏ü‡∏Å‡∏π‡πâ‡∏†‡∏±‡∏¢

```cpp
#include <Arduino.h>

// Motor Driver Pins
const int ENA = 5;  const int IN1 = 7;  const int IN2 = 8;
const int ENB = 6;  const int IN3 = 9;  const int IN4 = 10;

// SOS & FX Pins
const int PIN_BUZZER = 4;
const int PIN_STROBE = 7;
const int PIN_LIGHTS = 3;

void setup() {
  Serial.begin(115200);
  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
  pinMode(PIN_BUZZER, OUTPUT); pinMode(PIN_STROBE, OUTPUT);
  pinMode(PIN_LIGHTS, OUTPUT);
  
  Serial.println("Ghost Micro V5: Body Actuator Ready");
}

void loop() {
  if (Serial.available() >= 6) { // Updated to 6 bytes for flags
    if (Serial.read() == 0xAF) { // Signature
      int8_t throttle = Serial.read();
      int8_t steering = Serial.read();
      byte flags = Serial.read(); // Bit 0: RTH, Bit 1: Patrol
      byte sos = Serial.read();
      byte lights = Serial.read();

      // Handle Flags & Failsafe
      bool isRTH = flags & 0x01;
      bool isPatrol = flags & 0x02;

      if (isRTH) {
        // Execute Home-coming logic (e.g. follow path back)
        executeRTH();
      } else if (isPatrol) {
        // Execute Area Patrol logic within radius
        executePatrol();
      } else {
        // Simple Differential Drive
        int left = throttle + steering;
        int right = throttle - steering;
        driveMotor(ENA, IN1, IN2, left);
        driveMotor(ENB, IN3, IN4, right);
      }

      digitalWrite(PIN_BUZZER, (sos || isRTH) ? HIGH : LOW); // Buzz on RTH
      digitalWrite(PIN_STROBE, (sos && (millis() % 200 < 100)) ? HIGH : LOW);
      digitalWrite(PIN_LIGHTS, lights ? HIGH : LOW);
    }
  }
}

void executeRTH() {
  // TODO: Implement sensor-based return or reversal
  driveMotor(ENA, IN1, IN2, -50); // Dummy RTH (Backup slow)
  driveMotor(ENB, IN3, IN4, -50);
}

void executePatrol() {
  // TODO: Implement zig-zag or boundary-bounce logic
}

void driveMotor(int en, int i1, int i2, int speed) {
  int pwm = map(abs(speed), 0, 100, 0, 255);
  digitalWrite(i1, speed >= 0 ? HIGH : LOW);
  digitalWrite(i2, speed >= 0 ? LOW : HIGH);
  analogWrite(en, pwm);
}
```

---

---

> [!TIP]
> ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡∏û‡∏±‡∏í‡∏ô‡∏≤: ‡πÉ‡∏´‡πâ‡πÄ‡∏ô‡πâ‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏Ç‡∏≠‡∏á Ultrasonic ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Safe-Stop ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏à‡∏≠‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö
